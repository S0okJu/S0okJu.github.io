
[{"content":"","date":"16 April 2024","externalUrl":null,"permalink":"/tags/aws/","section":"Tags","summary":"","title":"AWS","type":"tags"},{"content":"","date":"16 April 2024","externalUrl":null,"permalink":"/posts/study/aws/","section":"Posts","summary":"","title":"AWS","type":"posts"},{"content":" Introduction # Terraform 코드를 분석하고 있었다. 어디에서는 IAM을 쓰고, 어디에서는 Profile을 쓴다. 과연 그 둘의 차이점은 무엇일까? 알아보도록 하자!\nProfile # Amazon Ec2는 IAM role을 가진 profile을 사용하게 된다.\n질문 1. awscli를 통해 profile을 지정할 수 있는데, 이것도 Instance Profile인가? # If you use the AWS CLI, API, or an AWS SDK to create a role, you create the role and instance profile as separate actions, with potentially different names. If you then use the AWS CLI, API, or an AWS SDK to launch an instance with an IAM role or to attach an IAM role to an instance, specify the instance profile name. 출처 - 공식 문서\n질문이 잘못되었다. EC2는 해당 IAM Role을 가진 Profile을 사용한다. 그래서 awscli의 경우 \u0026ndash;profile을 통해 직접 profile 이름을 지정할 수 있다. 왜 필요할까? # aws cli를 사용할 때 profile 기능을 이용하면 여러개의 자격 증명을 등록하고 스위칭해서 효율적으로 사용할 수 있습니다.\n출처 - https://cloudest.oopy.io/posting/101\n질문 2. IAM Role과의 차이점은? # Profile이 필요한 이유는 여러개의 자격 증명을 등록하고 스위칭해서 효율적으로 사용하기 위함이라고 했다. 특징을 봤을때 IAM의 Role과 비슷해 보였다.\nRoles are designed to be “assumed” by other principals which do define “who am I?”, such as users, Amazon services, and EC2 instances An instance profile, on the other hand, defines “who am I?” Just like an IAM user represents a person, an instance profile represents EC2 instances. The only permissions an EC2 instance profile has is the power to assume a role.\n출처 - https://www.quora.com/In-AWS-what-is-the-difference-between-a-role-and-an-instance-profile\nIAM Role은 무엇을 할 수 있는지에 대한 행위를 정의하는 것이라면 Profile Instance는 \u0026ldquo;누가 만들었는지를 정의하기\u0026rdquo; 위함이라면 보면 된다.\nConclusion # 내가 이러한 궁금증을 가지게 된 것은 IAM을 한사람에게만 부여된다고 생각했기 때문이었다. 그런 맥락에서는 profile이 필요 없기 때문이다. Reference # https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_switch-role-ec2_instance-profiles.html https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html ","date":"16 April 2024","externalUrl":null,"permalink":"/posts/study/aws/iam-and-profile/","section":"Posts","summary":"Introduction # Terraform 코드를 분석하고 있었다.","title":"AWS - IAM 그리고 Profile","type":"posts"},{"content":"","date":"16 April 2024","externalUrl":null,"permalink":"/","section":"NooOTe","summary":"","title":"NooOTe","type":"page"},{"content":"","date":"16 April 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"16 April 2024","externalUrl":null,"permalink":"/posts/study/","section":"Posts","summary":"","title":"Study","type":"posts"},{"content":"","date":"16 April 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"10 April 2024","externalUrl":null,"permalink":"/tags/gin/","section":"Tags","summary":"","title":"Gin","type":"tags"},{"content":"Thumbnail: Designed by Freepik\n이전에는 Gin이 어떻게 예외 처리를 하는지 언급했다. 이제부터 직접 구현하고자 한다.\nError Wrapping # 직접 제작한 에러 코드인 WebCode와 에러를 감싼 NetError를 만들었다.\ntype NetError struct { Code codes.WebCode Err error } 프로젝트 구현할때 주로 gin 혹은 ent 라이브러리를 쓴다. 별도의 Error 구조체(NetError)를 정의함으로써 Err에 gin 혹은 ent 에러를 담겠다는 의미인 것이다.\nGin에서의 예외 처리 # Gin Error() 함수에 의하면 Gin의 Context에 Error를 담은 후에 Middleware에서 처리하는 것을 권장하고 있다.\nError attaches an error to the current context. The error is pushed to a list of errors. It\u0026rsquo;s a good idea to call Error for each error that occurred during the resolution of a request. A middleware can be used to collect all the errors and push them to a database together, print a log, or append it in the HTTP response. Error will panic if err is nil.\n라이브러리 코드를 보면 Errors 필드가 정의되어 있는데, errorMsg는 []*Error 에러 리스트로 타입을 가지고 있다. 위의 설명대로 error의 리스트가 Context 내부에 구현되어 있는 것이다.\n// gin/context.go type Context struct { // ... Errors errorMsgs // .. } // gin/errors.go type errorMsgs []*Error 즉, ctx.Error를 활용하여 입력받은 에러를 Gin의 에러로 감싼 후에 Context의 Errors 리스트에 넣게 된다.\n// gin/context.go // Error attaches an error to the current context. The error is pushed to a list of errors.// It\u0026#39;s a good idea to call Error for each error that occurred during the resolution of a request.// A middleware can be used to collect all the errors and push them to a database together, // print a log, or append it in the HTTP response. // Error will panic if err is nil. func (c *Context) Error(err error) *Error { if err == nil { panic(\u0026#34;err is nil\u0026#34;) } var parsedError *Error ok := errors.As(err, \u0026amp;parsedError) if !ok { parsedError = \u0026amp;Error{ Err: err, Type: ErrorTypePrivate, } } c.Errors = append(c.Errors, parsedError) return parsedError } Context 내부에 있는 Error 리스트는 Middleware에서 처리하게 된다.\nGin에서는 HandlerFunc를 slice로 구현된 HandlerChain이 있는데, 이는 Gin이 각가지의 Handler를 Chain내에 넣고 처리하는 것이다.\ntype HandlersChain []HandlerFunc 그럼 오류를 어떻게 발생시키면 될까? HandlerChain 내에 있는 대기 중인(Pending) Handler를 호출하지 않도록 하면된다. 즉, Context를 Abort하면 되는 것이다. 그 이후에 처리할 Handler가 없어지면서 종료가 된다.\nAbort prevents pending handlers from being called. Note that this will not stop the current handler. Let\u0026rsquo;s say you have an authorization middleware that validates that the current request is authorized. If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers for this request are not called.\n프로젝트에 적용하기 # 절차 # 위의 내용을 가지고 실제로 적용해보자. 프로젝트 구성은 3계층으로 커스텀 에러 감싸기는 서비스 로직에 수행하도록 했다.\nService 계층에 Error Wrapping을 한다. Controller에 context 내에 있는 에러 리스트에 예외를 넣는다. Middleware에 Error Wrapping한 것을 Unwrapping 하면서 예외 타입을 학인한다. 커스텀 에러라면 WebCode에 따른 응답값을 반환한다. 그림으로 표현하자면 아래와 같다. 코드 # 코드는 아래의 두 사이트를 참고했습니다.\nNaver D2, Golang, 그대들은 어떻게 할 것인가 - 3. error 래핑 Naver D2, Golang, 그대들은 어떻게 할 것인가 - 4. error 핸들링 Service Layer # Persistence Layer에서 얻은 에러 값을 직접 받은 후에 Service 계층에서 적절하게 NetError로 감싼다.\n// service func (s *MemberService) CreateMember(ctx *gin.Context, req data.RegisterReq) (*ent.Member, *errorutils.NetError) { // Check member Exist existedMem, err := s.Store.GetMemberByEmail(ctx, req.Email) if err != nil { return nil, \u0026amp;errorutils.NetError{Code: codes.MemberInternalServerError, Err: err} } if ent.IsNotFound(err) { mem, err2 := s.Store.Create(ctx, req) if err2 != nil { return nil, \u0026amp;errorutils.NetError{Code: codes.MemberCreationError, Err: err2} } return mem, nil } return existedMem, nil } Controller Layer # Controller는 Service 계층에서 감싼 커스텀 에러를 받은 후에 Context의 에러 리스트에 넣는다.\nfunc (controller *MemberController) RegisterMember(ctx *gin.Context) { req := data.RegisterReq{} err := ctx.ShouldBindJSON(\u0026amp;req) if err != nil { _ = ctx.Error(errorutils.NewNetError(codes.MemberInvalidJson, err)) return } // Create member mem, err2 := controller.service.CreateMember(ctx, req) if err2 != nil { // Service 계층에서 받은 에러를 Context 내 에러 리스트에 넣는다. _ = ctx.Error(err2) return } mid := data.MemberId{MemberId: mem.ID} response.SuccessWith(ctx, codes.MemberCreationSuccess, mid) } Middleware # 에러 응답값을 반환할 HandlerFunc를 구현한다.\nNext를 활용하여 대기 중인 핸들러를 실행시킨다. errors.As를 활용하여 Context 에러 리스트에 있는 에러가 커스텀 에러인지 확인한다. 정확히 말하자면 에러를 unwrapping하면서 커스텀 에러인지 확인한 후에 있다면 netError에 넣게 된다. WebCode를 활용하여 응답값을 얻은 후 AbortWithStatusJson 를 활용하여 Response json을 전송한다. func ErrorHandler() gin.HandlerFunc { return func(ctx *gin.Context) { // Pending 중인 핸들러 실행 ctx.Next() // JSON이 두번 쓰이는 것을 대비해서 Body 확인 isBodyWritten := ctx.Writer.Written() err := ctx.Errors.Last() if err != nil { // 커스텀 에러인지 확인 var netErr *errorutils.NetError if errors.As(err, \u0026amp;netErr) { code := netErr.GetCode() statusCode := codes.GetStatus(code) res := response.NewErrorResponse(code) if !isBodyWritten { ctx.AbortWithStatusJSON(int(statusCode), res) } } else { res := response.NewErrorResponse(codes.GlobalInternalServerError) if !isBodyWritten { ctx.AbortWithStatusJSON(http.StatusInternalServerError, res) } } } } } 마무리 # Go의 예외 매커니즘은 다른 언어와 달라서 틀을 잡는데 많은 시간을 사용했다. 공식 문서나 다른 사람들의 예제 코드를 분석하면서, Go 스러움이 무엇인지 자츰 배워간다는 느낌이다. 그러나 코드양이 많아지면서 오히려 코드가 복잡해지는 것 같기도 하다.\n","date":"10 April 2024","externalUrl":null,"permalink":"/posts/project/todopoint/gin-error-handling2/","section":"Posts","summary":"Thumbnail: Designed by Freepik","title":"Gin 예외처리 - 2. 커스텀 예외처리","type":"posts"},{"content":"","date":"10 April 2024","externalUrl":null,"permalink":"/tags/golang/","section":"Tags","summary":"","title":"Golang","type":"tags"},{"content":"","date":"10 April 2024","externalUrl":null,"permalink":"/posts/project/","section":"Posts","summary":"","title":"Projects","type":"posts"},{"content":" GitHub : Thumbnail: Designed by Freepik ","date":"10 April 2024","externalUrl":null,"permalink":"/posts/project/todopoint/","section":"Posts","summary":" GitHub : Thumbnail: Designed by Freepik ","title":"Todopoint","type":"posts"},{"content":"Thumbnail: Designed by Freepik\nGo와 예외처리 # Go에서의 예외처리 # Go에서는 함수에서 반환된 에러 객체(error)로 처리한다. 다행히도 multi-return이 가능하기에 에러 반환을 더욱 수월하게 해줄 수 있다.\nf, err := Sqrt(-1) if err != nil { fmt.Println(err) } try ~ catch가 없는 이유 # 공식 문서에 의하면 try ~ catch는 난해한 코드를 생성하며, 개발자에게 너무많은 일반적인 예외를 처리하도록 장려한다고 한다.\nWe believe that coupling exceptions to a control structure, as in the try-catch-finally idiom, results in convoluted code. It also tends to encourage programmers to label too many ordinary errors, such as failing to open a file, as exceptional.\n다른 언어처럼 try ~ catch 를 어렴풋이 구현할 수 있다. 중간에 실행의 흐름을 끊는 panic 함수를 사용하는 것이다. 하지만 반대로 생각하자면 모든 에러들을 panic으로 처리해야 할까? Go에서는 그것이 아니라는 것이다. 이런 이유로 Go는 시의적절하기 예외처리할 수 있도록 error를 반환하는 방식으로 처리하게 된다.\nError - Wrapping # Go에서는 에러처리할 때 Error 객체를 넘겨준다고 한다. 물론 일반 에러 객체를 넘겨줄 수 있지만 개발자가 직접 만든 에러를 만들어서 넘겨줄 수 있다. Error Wrapping이란 쉽게 말하자면 error 객체를 감싸는 또다른 구조체를 만드는 것이라고 보면 된다.\ngin에서의 Error를 봐보자. gin의 Error 내에 필드로 error가 존재한다. 이러한 과정을 Error Wrapping이라고 보면 된다.\n// Error represents a error\u0026#39;s specification. type Error struct { Err error Type ErrorType Meta any } 그럼 예를 들어보자. ctx.Error를 실행했는데 의도치 않게 errors.As가 적절하게 실행되지 않는다고 가정해보자. error.As는 Error Type을 확인하는 함수인데, 만약에 타입이 적절하지 않는다면, 입력한 error을 감싼 Error를 반환하게 된다.\nfunc (c *Context) Error(err error) *Error { if err == nil { panic(\u0026#34;err is nil\u0026#34;) } var parsedError *Error ok := errors.As(err, \u0026amp;parsedError) if !ok { parsedError = \u0026amp;Error{ Err: err, Type: ErrorTypePrivate, } } c.Errors = append(c.Errors, parsedError) return parsedError } 그럼 원본 에러(error)에 접근할 수 있을까? 바로 Unwrap를 통해 얻을 수 있은 것이다.\n// Unwrap returns the wrapped error, to allow interoperability with errors.Is(), errors.As() and errors.Unwrap() func (msg *Error) Unwrap() error { return msg.Err } 그림으로 표현하면 아래와 같다.\n기존의 문제점 # Gin Context의 잘못된 활용법 # 공식 문서에서 말하는 Context는 데드라인, 취소 시그널, API에 대한 경계값을 가지는 값으로 정의된다. 그래서 조건에 따라 실행이 중단될 수 있다는 것으로 이해했다. gin은 자체적인 Context를 가지고 있으며, context를 중단시킬 수 있는 여러 함수들이 존재한다.\nService Layer에서 커스텀 에러 타입으로 반환하도록 구현했다.\nfunc (controller *MemberController) RegisterMember(ctx *gin.Context, req request.RegisterReq) { req = request.RegisterReq{} err := ctx.ShouldBindJSON(req) // ... // Create member err2 := controller.service.CreateMember(ctx, req) if err2 != nil { errorutils.ErrorFunc(ctx, err2) return } webutils.Success(ctx) } 커스텀 에러 타입을 자세히 보면, 자체적으로 제작한 에러 코드와 error을 담을 Err 필드가 존재한다.\ntype Error struct { // Code is a custom error codes ErrorType ErrorType // Err is a error string Err error // Description is a human-friendly message. Description string } 애플리케이션에 오류 발생시 현재 실행을 멈추고, 응답값을 보내는 ErrorFunc도 만들었다.\nfunc ErrorFunc(ctx *gin.Context, err *Error) { res := getCode(err.ErrorType) ctx.AbortWithStatusJSON(res.Code, res) return } 공식 문서 에 의하면AbortWithStatusJSON에는 내부적으로 Context를 중단시킬 수 있는Abort 함수를 사용한다. 구체적으로 Abort 함수는 현재의 handler는 그대로 남지만, 그 이후의 handler를 처리하지 않겠다는 것이다.\nAbort prevents pending handlers from being called. Note that this will not stop the current handler. Let\u0026rsquo;s say you have an authorization middleware that validates that the current request is authorized. If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers for this request are not called.\n문장을 보면서 내가 Gin 프레임워크의 에러처리를 완전히 잘못했음을 깨닫게 되었다.\nGin Error 미사용 # 공식 문서에 의하면 Gin은 자신들의 Error를 사용하는 것을 권장하며, middleware가 이를 처리하여 오류 response를 처리하라고 명시되어 있다.\nError attaches an error to the current context. The error is pushed to a list of errors. It\u0026rsquo;s a good idea to call Error for each error that occurred during the resolution of a request. A middleware can be used to collect all the errors and push them to a database together, print a log, or append it in the HTTP response. Error will panic if err is nil.\n즉, 오류가 발생할때마다 gin의 Context에서 제공해주는 Error로 감싸며, Middleware에 있는 Handler가 이를 순차적으로 처리해야 한다는 것이다.\n2부에서는 # 지금까지는 내가 만들었던 예외처리에는 어떠한 문제점이 있는지 확인해봤다. 2부에서는 위에서 설명한 잘못된 에러처리를 공식문서에서 제시한 올바른 에러처리를 구현하고자 한다.\nMiddleware에 Handler 구현 gin.Error를 활용하여 Error를 wrapping하고, Middleware에서 처리하기 ","date":"3 April 2024","externalUrl":null,"permalink":"/posts/project/todopoint/gin-error-handling1/","section":"Posts","summary":"Thumbnail: Designed by Freepik","title":"Gin 예외처리 - 1. Go Error","type":"posts"},{"content":"","date":"25 January 2024","externalUrl":null,"permalink":"/posts/study/lac/","section":"Posts","summary":"","title":"laC","type":"posts"},{"content":"","date":"25 January 2024","externalUrl":null,"permalink":"/tags/terraform/","section":"Tags","summary":"","title":"Terraform","type":"tags"},{"content":" Terraform 이란 # HashiCorp에서 오픈소스로 개발중인, 클라우드 및 온프로미스 인프라를 코드로 관리할 수 있는 코드이다. 인프라 환경 구성 시 선언적 코드형식을 사용하여 리소스를 생성, 수정, 삭제하여 관리가 가능한 laC(Infrastructure as Code) 프로비저닝 도구이다.\nTerraform 작동 방식 # 주로 Write, Plan, Apply 절차로 이뤄진다.\nWrite : Hashicorp에서 자체 개발한 HCL 언어로 스크립트 작성 Plan : 상태를 비교하며 변경점을 사용자에게 보여줌 Apply : 실행하는 단계, 순차적으로 실행 의존 관계에 따라 순서를 명시할 수 있다. 출처 - Terraform 공식 홈페이지\n상태 비교를 통해 휴먼 에러를 줄일 수 있다. 그러나 코드의 무게가 무거워지면, 실행하는데 오래걸리는 원인이 될 수 있다. 그 외에도 다양한 단점이 존재할 것이다. 그럼에도 불구하고 생산성 측면, 종속성 그래프 등 장점들이 더 크기 때문에 사용하는 것이다.\n클라우드 컴퓨팅 환경은 참조된 리소스가 처음의 리소스를 참조하는 순환루프 문제를 지니고 있다. 무한한 반복으로 인해 시스템이 빠르게 고갈되고, 성능이 저하된다. Terraform에서는 리소스의 참조 내용을 그래프로 보여주는 Resource Graph를 제공해주는데, 이를 활용해 순환루프 문제를 예방할 수 있다.\n연습 # 자세한 문법은 Terraform Language Documentation을 참고하길 바란다.\n시나리오 # AWS를 활용한다. 개발, 운영 VPC를 구축한다. 각 VPC에서 private, public subnet이 존재한다. 외부와 통신을 위해 internet gateway와 내부 리소스끼리만 통신할 수 있는 NAT gateway를 설치한다. 출처 - 저자\n구현 # AWS를 활용한다. Terraform AWS Registry에서 제공해주는 코드를 그대로 사용한다. 나의 경우 region을 ap-northeast-2 로 설정했다.\n// ./main.tf terraform { required_providers { aws = { source = \u0026#34;hashicorp/aws\u0026#34; version = \u0026#34;~\u0026gt; 5.0\u0026#34; } } } # Configure the AWS Provider provider \u0026#34;aws\u0026#34; { region = \u0026#34;ap-northeast-2\u0026#34; } 개발 운영 vpc를 구축한다. vpc 모듈을 별도로 만들어 코드를 재사용했고, env를 변수로 삼아 리소스의 이름에 개발 환경을 명시하도록 했다.\n// ./main.tf // For Dev module \u0026#34;dev_vpc\u0026#34; { source = \u0026#34;./vpc.d\u0026#34; env = \u0026#34;dev\u0026#34; } // For Production module \u0026#34;prd_vpc\u0026#34; { source = \u0026#34;./vpc.d\u0026#34; env = \u0026#34;prd\u0026#34; } 모듈의 main.tf에는 public, private Subnet 그리고 NAT gateway, Internet gateway를 생성하는 코드를 작성했다.\nPrivate Subnet을 구성하기 위해서는 라우팅 테이블이 필요하지만, 임시이므로 Private NAT Gateway만 작성했다. 여기서 주목해야 할 점은 NAT, Internet Gateway의 경우 Subnet이 우선적으로 만들어져야 실행된다.(만약에 그러지 않는다면 오류가 뜬다.) 그러므로 코드를 작성할때 각 리소스의 의존성을 고려해서 작성해야 한다.\n// ./vpc.d/main.tf terraform { required_providers { aws = { source = \u0026#34;hashicorp/aws\u0026#34; version = \u0026#34;~\u0026gt; 5.0\u0026#34; } } } // Configure the AWS Provider provider \u0026#34;aws\u0026#34; { region = \u0026#34;ap-northeast-2\u0026#34; } // Create a VPC resource \u0026#34;aws_vpc\u0026#34; \u0026#34;default\u0026#34; { cidr_block = \u0026#34;10.0.0.0/16\u0026#34; tags = { Name = \u0026#34;terraform_default_vpc_${var.env}\u0026#34; } } // public subnet resource \u0026#34;aws_subnet\u0026#34; \u0026#34;public_subnet_1\u0026#34; { vpc_id = aws_vpc.default.id cidr_block = \u0026#34;10.0.0.0/24\u0026#34; tags = { Name = \u0026#34;terraform_public_subnet_1_${var.env}\u0026#34; } } // private subnet resource \u0026#34;aws_subnet\u0026#34; \u0026#34;private_subnet_1\u0026#34; { vpc_id = aws_vpc.default.id cidr_block = \u0026#34;10.0.10.0/24\u0026#34; tags = { Name = \u0026#34;terraform_private_subnet_1_${var.env}\u0026#34; } } // private NAT resource \u0026#34;aws_nat_gateway\u0026#34; \u0026#34;private_nat\u0026#34; { connectivity_type = \u0026#34;private\u0026#34; subnet_id = aws_subnet.private_subnet_1.id tags = { Name = \u0026#34;terraform_nat_${var.env}\u0026#34; } } // Internet gateway resource \u0026#34;aws_internet_gateway\u0026#34; \u0026#34;igw\u0026#34; { vpc_id = aws_vpc.default.id tags = { Name = \u0026#34;terraform_igw_${var.env}\u0026#34; } } Terraform 도입과 관련된 기술 블로그 # 좌충우돌 Terraform 입문기, 우아한형제들 기술블로그 DevOps팀의 Terraform 모험 Terraform IaC 도구를 활용한 AWS 웹콘솔 클릭 노가다 해방기 → 다들 웹콘솔에서의 해방을 외치고 있었다..\n","date":"25 January 2024","externalUrl":null,"permalink":"/posts/study/lac/basic-terraform1/","section":"Posts","summary":"Terraform 이란 # HashiCorp에서 오픈소스로 개발중인, 클라우드 및 온프로미스 인프라를 코드로 관리할 수 있는 코드이다.","title":"Terraform 기초 맛보기 - 1. 기본 문법 익히기","type":"posts"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]