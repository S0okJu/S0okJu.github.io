<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h3>Gin 예외처리 — Part 1. 프로젝트 코드로 살펴보는 예외처리 문제점</h3> <h3>Go와 예외처리</h3> <h4>일반적인 Go의 예외처리 방법</h4> <p>Go에서는 함수에서 반환된 <a href="https://go.dev/blog/error-handling-and-go" rel="external nofollow noopener" target="_blank">에러 객체(error)</a>로 처리합니다. 다행히도 multi-return이 가능하기에 에러 반환을 더욱 수월하게 해줄 수 있습니다.</p> <pre>f, err := Sqrt(-1)<br>if err != nil {<br>    fmt.Println(err)<br>}</pre> <h4>try ~ catch가 없는 이유</h4> <p><a href="https://go.dev/doc/faq#exceptions" rel="external nofollow noopener" target="_blank">공식 문서</a>에 의하면 try ~ catch는 난해한 코드를 생성하며, 개발자에게 너무많은 일반적인 예외를 처리하도록 장려합니다.</p> <blockquote> <em>We believe that coupling exceptions to a control structure, as in the </em><em>try-catch-finally idiom, results in convoluted code. It also tends to encourage programmers to label too many ordinary errors, such as failing to open a file, as exceptional.</em> </blockquote> <p>다른 언어처럼 try ~ catch 를 어렴풋이 구현할 수 있습니다. 바로 중간에 실행의 흐름을 끊는panic함수를 사용하는 것입니다.<br>반대로 생각하자면 <strong>모든 에러들을 panic으로 처리해야 할까?</strong> 라고 생각하면 좋은 선택지는 아니라고 생각합니다.<br>이런 이유로 Go는 시의적절하기 예외처리할 수 있도록 error를 반환하는 방식으로 처리합니다.</p> <h4>Error Wrapping</h4> <p>Error Wrapping이란 쉽게 말하자면 error 객체를 감싸는 또다른 구조체를 만드는 것입니다.<br>Go에서는 에러처리할 때 Error 객체를 넘겨줍니다. 물론 일반 에러 객체를 넘겨줄 수 있지만 개발자가 직접 만든 에러를 만들어서 넘겨줄 수 있습니다.</p> <p>gin에서의 Error를 확인하겠습니다. gin의 Error 내에 필드로 error가 존재합니다. 아래 코드와 같은 과정을 Error Wrapping이라고 보면 됩니다.</p> <pre>// Error represents a error's specification.<br>type Error struct {  <br>    Err  error  <br>    Type ErrorType  <br>    Meta any  <br>}</pre> <p>ctx.Error를 실행했는데 의도치 않게 errors.As가 적절하게 실행되지 않는다고 가정하겠습니다.error.As는 Error Type을 확인하는 함수인데, 만약에 타입이 적절하지 않는다면, 입력한 error을 감싼 Error를 반환하게 됩니다.</p> <pre>func (c *Context) Error(err error) *Error {  <br>    if err == nil {  <br>       panic("err is nil")  <br>    }  <br>  <br>    var parsedError *Error  <br>    ok := errors.As(err, &amp;parsedError)  <br>    if !ok {  <br>       parsedError = &amp;Error{  <br>          Err:  err,  <br>          Type: ErrorTypePrivate,  <br>       }  <br>    }  <br>  <br>    c.Errors = append(c.Errors, parsedError)  <br>    return parsedError  <br>}</pre> <p>원본 에러(error)는 Unwrap()함수를 통해 얻을 수 있습니다.</p> <pre>// Unwrap returns the wrapped error, to allow interoperability with errors.Is(), errors.As() and errors.Unwrap()  <br>func (msg *Error) Unwrap() error {  <br>    return msg.Err  <br>}</pre> <p>Error의 구조를 정리하면 아래와 같습니다.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/551/1*1EEloxJEdNcRKxt5NiZW0A.png"><figcaption>Error 구조</figcaption></figure> <h3>프로젝트 코드의 문제점</h3> <h4>Gin Context의 잘못된 활용</h4> <p><a href="https://pkg.go.dev/context#pkg-overview" rel="external nofollow noopener" target="_blank">공식 문서</a>에서 말하는 Context는 데드라인, 취소 시그널, API에 대한 경계값을 가지는 값으로 정의합니다. 초반에는 조건에 따라 실행이 중단될 수 있다는 것으로 이해했습니다.</p> <p>gin은 자체적인 Context를 가지고 있으며, context를 중단시킬 수 있는 여러 함수들이 존재합니다. gin에서 제공하는 context를 활용하여 Service Layer에서 커스텀 에러 타입으로 반환하도록 구현해보겠습니다.</p> <pre>func (controller *MemberController) RegisterMember(ctx *gin.Context, req request.RegisterReq) {<br> req = request.RegisterReq{}<br> err := ctx.ShouldBindJSON(req)<br> // ... <br> // Create member<br> err2 := controller.service.CreateMember(ctx, req)<br> if err2 != nil {<br>  errorutils.ErrorFunc(ctx, err2)<br>  return<br> }<br> webutils.Success(ctx)<br>}</pre> <p>커스텀 에러 타입을 자세히 보면, 자체적으로 제작한 에러 코드와 error을 담을 Err 필드가 존재합니다.</p> <pre>type Error struct {<br> // Code is a custom error codes<br> ErrorType ErrorType<br> // Err is a error string<br> Err error<br> // Description is a human-friendly message.<br> Description string<br>}</pre> <p>애플리케이션에 오류 발생시 현재 실행을 멈추고, 응답값을 보내는 ErrorFunc 함수도 만들었습니다.</p> <pre>func ErrorFunc(ctx *gin.Context, err *Error) {<br> res := getCode(err.ErrorType)<br><br> ctx.AbortWithStatusJSON(res.Code, res)<br> return<br>}</pre> <p><a href="https://pkg.go.dev/github.com/gin-gonic/gin#Context.Abort" rel="external nofollow noopener" target="_blank">공식 문서</a> 에 의하면AbortWithStatusJSON에는 내부적으로 Context를 중단시킬 수 있는Abort 함수를 사용합니다. 구체적으로 <a href="https://pkg.go.dev/github.com/gin-gonic/gin#Context.Abort" rel="external nofollow noopener" target="_blank">Abort 함수</a>는 현재의 handler는 그대로 남지만, 그 이후의 handler를 처리하지 않겠다는 것이다. 즉, <strong>Abort()를 실행한 이후에도 남은 코드가 실행</strong>되는 것입니다.</p> <h4>Gin Error 미사용</h4> <p><a href="https://pkg.go.dev/github.com/gin-gonic/gin#Context.Error" rel="external nofollow noopener" target="_blank">공식 문서</a>에 의하면 Gin은 자신들의 Error를 사용하는 것을 권장하며, middleware가 이를 처리하여 오류 response를 처리하라고 명시되어 있습니다.</p> <blockquote>Error attaches an error to the current context. The error is pushed to a list of errors. It’s a good idea to call Error for each error that occurred during the resolution of a request. A middleware can be used to collect all the errors and push them to a database together, print a log, or append it in the HTTP response. Error will panic if err is nil.</blockquote> <p>즉, 오류가 발생할때마다 gin의 Context에서 제공해주는 Error로 감싸며, Middleware에 있는 Handler가 이를 순차적으로 처리해야 한다는 것입니다.</p> <h3>2부에서는</h3> <p>지금까지는 내가 만들었던 예외처리에는 어떠한 문제점이 있는지 확인해봤습니다.</p> <p>2부에서는 위에서 설명한 잘못된 에러처리를 공식문서에서 제시한 올바른 에러처리를 구현해보겠습니다.</p> <ul> <li>Middleware에 Handler 구현</li> <li>gin.Error를 활용하여 Error를 wrapping하고, Middleware에서 처리하기</li> </ul> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=c2afdf7e7be2" width="1" height="1" alt="">&lt;hr&gt;&lt;p&gt;<a href="https://medium.com/s0okju-tech/gin-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC-part-1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A1%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%8A%94-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC-%EB%AC%B8%EC%A0%9C%EC%A0%90-c2afdf7e7be2" rel="external nofollow noopener" target="_blank">Gin 예외처리 — Part 1. 프로젝트 코드로 살펴보는 예외처리 문제점</a> was originally published in <a href="https://medium.com/s0okju-tech" rel="external nofollow noopener" target="_blank">S0okJu Technology Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</p> </body></html>