<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h3>GitOps 전환기 — Part 4. Tekton을 활용한 CI 구성하기</h3> <h3>Tekton 이란</h3> <p>Tekton이란 클라우드 네이티브 CI/CD 도구입니다. Tekton의 주요 컴포넌트인 Tekton Pipelines, Trigger로 이뤄져 있으며 쿠버네티스 CR(Custom Resource)를 활용해 선언적으로 CI/CD를 구성할 수 있습니다.</p> <h4>Jenkins vs Tekton</h4> <p>Jenkins는 가장 많이 사용되고 있는 CI/CD 도구이며, 다양한 플러그인을 통해 기능을 확장할 수 있습니다. 반면 JVM 기반으로 실행되기 대문에 메모리를 크게 사용하며, 리소스 초과 사용 시 서버 전체가 다운될 수 있습니다.</p> <p>Tekton은 클라우드 네이티브 CI/CD 도구이며, 쿠버네티스 클러스터 내부에서 독립적인 모듈 단위로 작업을 수행할 수 있습니다. 또한 Auto Scaling, Self-Healing, Serverless 기능을 가지고 있어 리소스 사용 효율성과 관리 측면에서 이점을 가지고 있습니다. 그러나 러닝 커브가 높은 편이고 자료가 많이 없다는 단점을 가지고 있습니다.</p> <blockquote>자세한 사항은 <a href="https://velog.io/@sgwon1996/Jenkins-vs-GitHub-Action-vs-Tekton" rel="external nofollow noopener" target="_blank">Jenkins vs GitHub Action vs Tekton</a> 글을 참고하시길 바랍니다.</blockquote> <p>물론 GitHub Actions라는 선택지도 있었습니다. 그러나 프로젝트에서는 3개의 레포지토리를 활용하므로 하므로 GitHub Actions는 선택지에 제외되었습니다.</p> <ol> <li>각 레포지토리마다 Git Actions를 설정해야 함 -&gt; <strong>중앙집중화된 관리 체계 필요</strong> </li> <li>Public만 무료로 제공 -&gt; <strong>Public, Private 레포지토리에 동시에 접근 가능해야 함.</strong> </li> </ol> <h4>Tekton 선택 이유</h4> <p>이전에는 별도의 인스턴스에 Jenkins를 설치해서 운영하고 있었습니다. 인프라 운영 과정에서 메모리 공간을 확보하기 위해 인스턴스 정리가 필요했고, 젠킨스가 설치된 인스턴스를 삭제하기로 결정했습니다. 그 대신 <strong>쿠버네티스 내에 CI 도구를 활용하는 방향으로 결정</strong>했습니다.</p> <p>Jenkins 또한 Kubernetes 내에서 배포할 수 있습니다. 그러나 <strong>파이프라인 구동 시에 리소스를 사용한다는 Serverless 특정 때문에 Tekton를 최종적으로 선택</strong>하게 되었습니다.</p> <h3>프로젝트에 적용하기</h3> <blockquote>해당 게시글은 Tekton의 사용법이 아닌 <strong>프로젝트에 어떻게 활용했는지에 집중합니다.</strong> 자세한 사항은 <a href="https://tekton.dev/docs/" rel="external nofollow noopener" target="_blank">공식 문서</a>를 참고하시길 바랍니다.</blockquote> <p>Tekton은 크게 <a href="https://tekton.dev/docs/triggers/" rel="external nofollow noopener" target="_blank">Triggers</a>, <a href="https://tekton.dev/docs/pipelines/" rel="external nofollow noopener" target="_blank">Pipelines</a> 컴포넌트로 이뤄져 있습니다. Triggers 컴포넌트는 EventListener 내부에 있는 모든 컴포넌트로 보시면 되고, Pipelines는 PipelineRun 내부 컴포넌트라고 보시면 됩니다.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/811/1*85HCS-zARzIu8TrCt72wrw.png"><figcaption>Tekton Resource type 종류</figcaption></figure> <h4>Task 구성하기</h4> <p><strong>개념</strong></p> <ul> <li>Step: 워크플로를 구성하는 기본적인 실행 단위로 쿠버네티스 파드 안의 컨테이너로 실행됩니다.</li> <li> <a href="https://tekton.dev/docs/pipelines/tasks/" rel="external nofollow noopener" target="_blank">Task</a>: 순서가 있는 Step의 모음으로, 각 Task가 실행될때마다 쿠버네티스 파드가 생성됩니다. 파드 내에서는 각 Step이 독립적인 컨테이너로 실행돼 서로 연관된 Step들끼리 환경 설정이나 볼륨을 공유할 수 있습니다.</li> <li> <a href="https://tekton.dev/docs/pipelines/taskruns/#overview" rel="external nofollow noopener" target="_blank">TaskRun</a>: Task를 인스턴스화하여 실행시킵니다. TaskRuns은 성공 혹은 실패할때까지 Task내의 Step들을 실행시킵니다.</li> </ul> <p>Task는 TaskRun이라는 CR를 통해 실행됩니다. 즉, <strong>Task는 작업할 흐름의 정의서로 보고 TaskRun은 Task의 실행 단위라고 보시면 됩니다.</strong></p> <p>단일 Task를 실행하기 위해서 TaskRun을 정의하여 사용할 수 있습니다. 그러나 프로젝트에서 CI를 구성할때는 Task의 상위 흐름 개념(Pipeline)을 활용하여 자동으로 TaskRun이 수행됩니다.</p> <p><strong>구성하기</strong></p> <p>GitOps 과정을 수행하기 위해서는 빌드를 마친 후에 Manifest를 변경시키는 작업이 필요합니다. Manifest 변경 작업은 우리는 이미지의 해시값을 kustomization.yaml에 업데이트하는 걸로 보시면 됩니다.</p> <p>그러기 위해서는 3가지 작업을 수행해야 합니다.</p> <ol> <li>특정 브랜치에 해당되는 레포지토리를 clone하여 가져오기</li> <li>이미지 빌드하기</li> <li>빌드한 이미지의 해시값을 config 레포지토리에 있는 kustomization.yaml에 업데이트하기</li> </ol> <p>Task를 직접 만들 수 있지만 <a href="https://hub.tekton.dev/" rel="external nofollow noopener" target="_blank">Tekton Hub</a>를 통해 간단한 파라미터 설정만으로도 Task를 수행할 수 있게 됩니다.</p> <p>그러므로 1, 2번 절차인 git-clone, 이미지 빌드 부분은 Tekton Hub에 있는 것들을 재사용할 예정입니다.</p> <ol> <li>git clone -&gt; <a href="https://hub.tekton.dev/tekton/task/git-clone" rel="external nofollow noopener" target="_blank">https://hub.tekton.dev/tekton/task/git-clone</a> </li> <li>이미지 빌드 -&gt; <a href="https://hub.tekton.dev/tekton/task/buildah" rel="external nofollow noopener" target="_blank">https://hub.tekton.dev/tekton/task/buildah</a> </li> </ol> <p>다만 3번 절차인 Manifest 변경은 직접 코드를 작성해줍니다.</p> <p>Task는 Step이 순차적으로 이뤄져 있다고 말씀 드렸습니다. Manifest 변경 작업을 더 세분화해서 Step으로 생성하면 됩니다.</p> <ol> <li>Config Repository를 clone한다.</li> <li>Kustomization.yaml를 찾아서 images 값을 업데이트한다.</li> <li>Config Repository의 변경 사항을 반영한다.</li> </ol> <p>params 값은 추후 Pipeline에서 값을 지정하게 됩니다. 임시로 값이 들어왔다는 전제로 파라미터를 활용한 코드를 작성해줍니다.</p> <pre>apiVersion: tekton.dev/v1beta1<br>kind: Task<br>metadata:<br>  annotations:<br>    tekton.dev/pipelilnes.minVersion: "0.19.0"<br>    tekton.dev/tags: git <br>  name: git-update-deployment<br>  labels:<br>    operator.tekton.dev/provider_type: community<br>spec:<br>  <br>  params:<br>    - name: GIT_REPOSITORY<br>      description: The URL of the Git repository to clone<br>      type: string<br>      default: ""<br>    - name: GIT_REF<br>      description: The Git revision to check out<br>      type: string<br>      default: "main"<br>    - name: NEW_IMAGE<br>      description: The name of the image to build and push<br>      type: string<br>    - name: NEW_DIGEST<br>      type: string <br>    - name: KUSTOMIZATION_PATH<br>      description: The name of the kustomization path to update <br>      type: string<br>  results:<br>    - name: GIT_COMMIT<br>      description: The commit hash of the updated repository<br>  workspaces:<br>    - name: shared<br>      description: The workspace to share between tasks<br>  steps:<br> # 1. Config Repository를 clone한다. <br>    - name: git-clone<br>      image: alpine/git:latest<br>      script: |<br>        #!/bin/sh<br>        set -ex<br>  # 기존에 있는 레포지토리 파일 삭제 <br>        if [ -d "$(workspaces.shared.path)/repo" ] &amp;&amp; [ "$(ls -A $(workspaces.shared.path)/repo)" ]; then<br>          rm -rf "/workspace/shared/repo"<br>        fi<br><br>  # git clone을 수행하여 원하는 브랜치로 Checkout 하기 <br>        git clone $(params.GIT_REPOSITORY) -b $(params.GIT_REF) $(workspaces.shared.path)/repo<br>        cd $(workspaces.shared.path)/repo <br>        git checkout $(params.GIT_REF)<br>        git rev-parse HEAD &gt; /workspace/shared/GIT_COMMIT.txt<br> <br> # 2. Kustomization.yaml를 찾아서 images 값을 업데이트한다. <br>    - name: update-kustomization<br>      image: smartive/kustomize:latest<br>      script: |<br>        #!/bin/sh<br>  # Config Repostiory 내 kustomization.yaml를 찾는다. <br>        cd $(workspaces.shared.path)/repo/$(params.KUSTOMIZATION_PATH)<br>        echo "Current directory: $(pwd)"<br><br>  # Image Hash를 업데이트한다. <br>        kustomize edit set image $(params.NEW_IMAGE)@$(params.NEW_DIGEST)<br>        cat kustomization.yaml<br><br> # 3. Config Repository의 변경 사항을 반영한다.<br>    - name: commit-changes<br>      image: alpine/git:latest<br>      script: |<br>        #!/bin/sh<br>        set -e<br>        cd $(workspaces.shared.path)/repo/$(params.KUSTOMIZATION_PATH)<br>        git config user.name &lt;github.username&gt;<br>        git config user.email &lt;github.email&gt;<br>        git status <br>        git add ./kustomization.yaml<br>        git commit -m "Update image to $(params.NEW_IMAGE)"<br>        git push<br>        EXIT_CODE="$?"<br>        if [ "$EXIT_CODE" -ne 0 ]; then<br>          echo "Error: Failed to push changes to the repository."<br>          exit 1<br>        fi<br>        echo "Changes pushed successfully.</pre> <h4>Pipeline 구성하기</h4> <p><strong>개념</strong></p> <ul> <li> <a href="https://tekton.dev/docs/pipelines/pipelines/#overview" rel="external nofollow noopener" target="_blank">Pipeline</a>: CI에 수행할 실행 흐름을 정의한 Task의 모음입니다. Pipeline에 있는 각각의 Task들은 Pod 형태로 실행됩니다.</li> <li> <a href="https://tekton.dev/docs/pipelines/pipelineruns/" rel="external nofollow noopener" target="_blank">PipelineRun</a>: Pipeline을 인스턴스화하여 실행시킵니다.</li> </ul> <p>Pipeline — PipelineRun과 Task — TaskRun은 거의 동일한 관계를 가진다고 보면 됩니다.</p> <p>Pipeline만 실행시키고 싶다면 PipelineRun을 정의하여 실행시킬 수 있습니다. 저희 프로젝트에서는 GitHub의 event에 맞춰 발생한 Trigger를 통해 자동으로 PipelineRun을 생성하도록 구성할 것입니다.</p> <p><strong>구성하기 </strong><br>지금까지 아래와 같은 Task를 생성했습니다.</p> <ol> <li>특정 브랜치에 해당되는 레포지토리를 clone하여 가져오기</li> <li>이미지 빌드하기</li> <li>빌드한 이미지의 해시값을 config 레포지토리에 있는 kustomization.yaml에 업데이트하기</li> </ol> <p>Task에서는 파라미터가 선언되어 있는데요. 해당 파라미터를 지정하여 모든 Task들을 하나의 Pipeline으로 생성합니다.</p> <pre>apiVersion: tekton.dev/v1beta1<br>kind: Pipeline<br>metadata:<br>  name: challenge-api-pipeline<br>  namespace: ci<br>spec:<br>  params:<br>    - name: repo-url<br>      type: string<br>    - name: revision<br>      type: string<br>      default: "main"<br>    - name: image-name<br>      type: string<br>    - name: context-dir<br>      type: string<br>      default: "." <br>    - name: config_git_repo<br>      type: string<br>    - name: config_git_ref<br>      type: string<br>      default: "main"<br><br>  workspaces:<br>    - name: shared  # 모든 태스크가 공유하는 워크스페이스<br><br>  tasks:<br># 1. 특정 브랜치에 해당되는 레포지토리를 clone하여 가져오기<br>    - name: git-clone<br>      taskRef:<br>        name: git-clone<br>      params:<br>        - name: url<br>          value: $(params.repo-url)<br>        - name: revision<br>          value: $(params.revision)<br>        - name: deleteExisting<br>          value: "true"<br>      workspaces:<br>        - name: output<br>          workspace: shared<br><br># 2. 이미지 빌드하기<br>    - name: buildah-build<br>      taskRef:<br>        name: buildah<br>      runAfter: ["git-clone"]<br>      params:<br>        - name: IMAGE<br>          value: $(params.image-name)<br>        - name: CONTEXT<br>          value: "$(workspaces.source.path)/$(params.context-dir)"<br>        - name: TLSVERIFY<br>          value: "false"<br>      workspaces:<br>        - name: source<br>          workspace: shared<br># 3. 빌드한 이미지의 해시값을 config 레포지토리에 있는 kustomization.yaml에 업데이트하기  <br>    - name: git-update-deployment<br>      taskRef:<br>        name: git-update-deployment<br>      runAfter: ["buildah-build"]<br>      params:<br>        - name: GIT_REPOSITORY<br>          value: $(params.config_git_repo)<br>        - name: GIT_REF<br>          value: $(params.config_git_ref)<br>        - name: NEW_IMAGE<br>          value: $(params.image-name)<br>        - name: NEW_DIGEST<br>          value: $(tasks.buildah-build.results.IMAGE_DIGEST)<br>        - name: KUSTOMIZATION_PATH<br>          value: "challenge-api/overlays/dev"<br>      workspaces:<br>        - name: shared<br>          workspace: shared</pre> <p>실행하면 아래와 같이 pod를 확인할 수 있습니다.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*sSdI_oykI2M_TFVhactuxw.png"><figcaption>kubectl get pod 결과</figcaption></figure> <h4>Trigger 구성하기</h4> <p><strong>개념</strong></p> <ul> <li> <a href="https://tekton.dev/docs/triggers/triggertemplates/" rel="external nofollow noopener" target="_blank">TriggerTemplate</a>: TaskRun 혹은 pipeline과 같은 리소스를 위한 청사진을 구체화하는 리소스입니다. EventListener에서 이벤트가 감지되면 TaskRun, PipelineRun이 인스턴스화되어 실행됩니다.</li> <li> <a href="https://tekton.dev/docs/triggers/triggerbindings/" rel="external nofollow noopener" target="_blank">TriggerBinding</a>: 이벤트 값으로부터 값을 추출하여 TriggerTemplate에 정의된 값을 바인딩합니다.</li> <li> <a href="https://tekton.dev/docs/triggers/eventlisteners/" rel="external nofollow noopener" target="_blank">Trigger</a>: TriggerTemplate과 TriggerBinding를 대응시키면 하나의 Trigger라고 불리게 됩니다.</li> </ul> <figure><img alt="" src="https://cdn-images-1.medium.com/max/820/1*OKxMKRoV133pceSpQ4h18A.png"><figcaption>출처 — <a href="https://tekton.dev/vault/triggers-main/" rel="external nofollow noopener" target="_blank">https://tekton.dev/vault/triggers-main/</a></figcaption></figure> <p><strong>구성하기</strong></p> <p>지금가지 새로 생성한 이미지의 정보(Manifest)를 kustomization.yaml 에 업데이트하는 Pipeline를 정의했습니다.</p> <p>이제부터는 GitHub의 변경 이벤트에 따라 CI가 진행될 수 있도록 구성해야 합니다. 그러기 위해서는 들어오는 GitHub 이벤트에 맞춰서 Trigger가 실행될 수 있도록 TriggerTemplate, TriggerBinding을 정의해야 합니다.</p> <p>이벤트로부터 레포지토리 url, revision 정보를 받아왔습니다. 해당 정보를 TriggerBinding을 통해 받고 TriggerTemplate에 적용할 수 있도록 구성했습니다.</p> <p>프로젝트에서는 main으로 merge하는 이벤트로만 실행할 수 있도록 설계했습니다. 그렇기 때문에 TriggerBinding을 통해 revision을 가져오는 것이 무의하다고 생각할 수 있을 것 같습니다. 추후 브랜치 전략을 체계적으로 짜게 된다면 이벤트로부터 받아들이는 값들이 유의미하게 적용될 수 있을 것 같습니다.</p> <pre>apiVersion: triggers.tekton.dev/v1beta1<br>kind: TriggerBinding<br>metadata:<br>  name: challenge-api-triggerbinding<br>  namespace: ci<br>spec: <br><br># GitHub Event json 구조를 참고하셔서 body 파라미터를 정의하셔야 합니다. <br>  params:<br>    - name: repo-url<br>      value: $(body.repository.clone_url)<br>    - name: revision<br>      value: $(body.after)<br>    - name: image-name<br>      value: &lt;image name&gt;</pre> <pre>apiVersion: triggers.tekton.dev/v1beta1<br>kind: TriggerTemplate<br>metadata:<br>  name: challenge-api-triggertemplate<br>spec:<br>  params:<br>    - name: repo-url<br>      description: The URL of the Git repository to clone<br>      default: &lt;default git url&gt;<br>    - name: revision<br>      description: The Git revision to check out<br>      default: "main"<br>    - name: image-name<br>      description: The name of the image to build and push<br>      default: &lt;default image name&gt;<br><br># PipelineRun 정의 <br>  resourcetemplates:<br>  - apiVersion: tekton.dev/v1beta1<br>    kind: PipelineRun<br>    metadata:<br>      labels:<br>        tekton.dev/pipeline: challenge-api-pipeline<br>      name:  challenge-api-$(uid)<br>    spec:<br>      pipelineRef:<br>        name: challenge-api-pipeline<br>      serviceAccountName: tekton-trigger-sa<br><br># TriggerTemplate은 tt.params를 참조합니다. <br>      params:<br>        - name: repo-url<br>          value: $(tt.params.repo-url)<br>        - name: revision<br>          value: $(tt.params.revision)<br>        - name: image-name<br>          value: $(tt.params.image-name)<br>      workspaces:<br>        - name: shared<br>          persistentVolumeClaim:<br>            claimName: challenge-api-pvc  # PVC 이름</pre> <h4>EventListener 구성하기</h4> <p><strong>개념</strong></p> <ul> <li> <a href="https://tekton.dev/docs/triggers/eventlisteners/" rel="external nofollow noopener" target="_blank">EventListener</a>: 쿠버네티스 내에서 특별한 포트를 통해 이벤트를 감지하는 쿠번에티스 오브젝트입니다. 들어오는 이벤트를 받아들인 후 하나 이상의 Trigger를 정의합니다.</li> <li> <a href="https://tekton.dev/vault/triggers-main/eventlisteners/#specifying-interceptors" rel="external nofollow noopener" target="_blank">Interceptor</a>: TriggerBinding 이전에 수행되는 특정 플랫폼에 대한 “catch-call” 이벤트 프로세서입니다. 주로 페이로드를 필터링, 검증 ,변형 등 다양한 작업을 수행할 수 있습니다. 만약에 특정 조건에 충족하게 되면 조건에 맞는 Trigger를 사용하게 됩니다.</li> </ul> <blockquote>자세히 알고 싶다면 <a href="https://www.redhat.com/en/blog/filtering-tekton-trigger-operations" rel="external nofollow noopener" target="_blank">Red Hat Blog — Filtering Tekton trigger operations</a>를 확인하시길 바랍니다.</blockquote> <p><strong>구성하기</strong></p> <p>저는 단일 EvenetListener를 정의하여 들어오는 레포지토리에 따라 서로 다른 Trigger를 수행하도록 정의할 것입니다. 왜냐하면 단일 EvenetListener를 정의함으로 관리하기 편하기 때문입니다.</p> <p>현재 온프로미스 환경에서 쿠버네티스 서버를 구동 중이기 때문에 NodePort를 통해 포트를 노출했습니다. GitHub에서 Webhook을 설정할때는 주소와 노출한 포트로 URL을 설정하면 됩니다.</p> <p>프로젝트에서는 크게 3개의 레포지토리를 빌드해야 합니다. 그렇게 때문에 각 레포지토리마다 main으로 merged된 이벤트 발생 시 Trigger가 발생할 수 있도록 설정했습니다.</p> <p>기본적으로 제공되는 GitHub <a href="https://tekton.dev/vault/triggers-main/clusterinterceptors/" rel="external nofollow noopener" target="_blank">ClusterInterceptor</a>를 통해 Interceptor를 구현할 수 있습니다. 그러나 저는 기본적인 <a href="https://github.com/google/cel-spec/blob/master/doc/langdef.md" rel="external nofollow noopener" target="_blank">CEL</a> Interceptor를 활용하여 필터링을 수행해보겠습니다.</p> <blockquote>CEL은 구글에서 제작한 빠르고 이동 가능하며 안전하게 실행하도록 설계된 범용 표현식 언어입니다. <br>출처 — <a href="https://cel.dev/overview/cel-overview?hl=ko" rel="external nofollow noopener" target="_blank">https://cel.dev/overview/cel-overview?hl=ko</a> </blockquote> <p>Trigger가 발생하는 조건은 아래와 같이 정했습니다.</p> <ol> <li>레포지토리가 helloworld/challenge-api인 경우</li> <li>main에 PR(Pull Request)를 수행한 경우</li> <li>Merge가 된 경우 -&gt; PR이 자동으로 closed 상태로 변함</li> </ol> <p>실제로 GitHub에 접속하셔서 Webhook&gt;Recent Deliveries에 접속하셔서 필터링하고자 하는 필드의 위치를 찾아 입력합니다.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/504/1*jImQ8nxxRN1EcRMdhz43PQ.png"><figcaption>Recent Delivieries 확인</figcaption></figure> <pre>apiVersion: triggers.tekton.dev/v1beta1<br>kind: EventListener<br>metadata:<br>  name: hexactf-listener<br>spec:<br>  resources:<br>    kubernetesResource:<br>      serviceType: NodePort<br>  serviceAccountName: tekton-trigger-sa<br>  triggers:<br>    - name: challenge-api-trigger<br>      interceptors:<br>      - ref:<br>          name: cel<br>        params:<br>        - name: filter<br>          value: "body.repository.full_name == 'helloworld/challenge-api' &amp;&amp; body.pull_request.base.ref =='main' &amp;&amp; body.action == 'closed' &amp;&amp; body.pull_request.merged==true"<br>      bindings:<br>      - ref: challenge-api-triggerbinding<br>      template:<br>        ref: challenge-api-triggertemplate</pre> <p>위와 동일하게 프로젝트 이름(body.repository.full_name)에 따라 서로 다른 Trigger를 실행할 수 있도록 설정했습니다. 이를 통해 하나의 Listener만을 가지고 다양한 Trigger를 실행할 수 있도록 구현했습니다.</p> <h3>Tekton 실행하기</h3> <p>GitHub 에서 PR을 수행하면 아래와 같은 변경사항을 확인할 수 있습니다.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/945/1*r6E-AEATchM611Pa6qIOpQ.png"><figcaption>tekton dashboard</figcaption></figure> <figure><img alt="" src="https://cdn-images-1.medium.com/max/773/1*r4JbnPlUKkMQf4iUfPBDog.png"><figcaption>config repository 변경사항</figcaption></figure> <h3>Tekton에 Slack 메세지 보내기</h3> <p><a href="https://hub.tekton.dev/tekton/task/send-to-webhook-slack" rel="external nofollow noopener" target="_blank">Send message to Slack Channel</a>, <a href="https://hub.tekton.dev/tekton/task/send-to-channel-slack" rel="external nofollow noopener" target="_blank">send-to-channel-slack</a> 과 같이 Slack에 메세지를 보내는 Task가 있습니다. 그러나 <strong>ArgoCD처럼 상태에 따라 메세지를 다르게 출력해주는 Task는 없는 것 같습니다.</strong></p> <p>기본적으로 상태에 따라 박스 색과 메세지 내용을 다르게 출력하도록 Task를 만들었습니다.</p> <blockquote>Task 구성 시 <a href="https://tekton.dev/docs/pipelines/variables/" rel="external nofollow noopener" target="_blank">필요 변수가 기본적으로 제공되는지 공식 문서</a>를 꼭 확인하시길 바랍니다.</blockquote> <pre>apiVersion: tekton.dev/v1beta1<br>kind: Task<br>metadata:<br>  name: send-to-channel-slack<br>  labels:<br>    app.kubernetes.io/version: "0.1"<br>  annotations:<br>    tekton.dev/pipelines.minVersion: "0.12.1"<br>    tekton.dev/categories: Messaging<br>    tekton.dev/tags: messaging<br>    tekton.dev/platforms: "linux/amd64,linux/s390x,linux/ppc64le"<br>spec:<br>  description: |<br>    이 태스크는 Slack 채널에 Tekton Bot 결과 메시지를 컬러 블록과 함께 전송합니다.<br>    성공 시 초록색, 실패 시 빨간색 컬러 바가 표시됩니다.<br>  params:<br>    - name: token-secret<br>      type: string<br>      description: secret name of the slack app access token (key는 token)<br>      default: token-secret<br>    - name: channel<br>      type: string<br>      description: channel id <br>    - name: status<br>      type: string<br>      description: Succeeded/Failed 등 파이프라인 상태<br>    - name: pipeline-name<br>      type: string<br>      description: 파이프라인 이름<br>    - name: pipelinerun-name<br>      type: string<br>    - name: username<br>      type: string<br>      description: 슬랙 메시지 발신자 이름<br>      default: "Tekton Bot"<br><br>  steps:<br>    - name: post<br>      image: curlimages/curl:7.70.0<br>      env:<br>        - name: TOKEN<br>          valueFrom:<br>            secretKeyRef:<br>              name: $(params.token-secret)<br>              key: token<br>      script: |<br>        #!/bin/sh<br>        if [ "$(params.status)" = "Succeeded" ]; then<br>          COLOR="#4BB543"<br>          EMOJI=":white_check_mark:"<br>          STATUS_TEXT="*성공*"<br>        else<br>          COLOR="#FF0000"<br>          EMOJI=":x:"<br>          STATUS_TEXT="*실패*"<br>        fi<br><br>        cat &lt;&lt;EOF &gt; /tmp/slack_message.json<br>        {<br>          "channel": "$(params.channel)",<br>          "username": "$(params.username)",<br>          "attachments": [<br>            {<br>              "color": "$COLOR",<br>              "blocks": [<br>                {<br>                  "type": "header",<br>                  "text": {<br>                    "type": "plain_text",<br>                    "text": "$EMOJI Tekton CI 결과"<br>                  }<br>                },<br>                {<br>                  "type": "section",<br>                  "text": {<br>                    "type": "mrkdwn",<br>                    "text": "*상태*: $STATUS_TEXT\n*파이프라인*: \`$(params.pipeline-name)\`"<br>                  }<br>                }<br>              ]<br>            }<br>          ]<br>        }<br>        EOF<br><br>        /usr/bin/curl -X POST \<br>          -H 'Content-type: application/json' \<br>          -H "Authorization: Bearer $TOKEN" \<br>          --data @/tmp/slack_message.json \<br>          https://slack.com/api/chat.postMessage</pre> <p>pipeline에서는 무조건 실행되어야 하므로 finally 에서 Task를 정의해줍니다. 상태값은 Pipeline이 아닌 Task 단위로 확인해야 하므로 tasks.status 변수를 통해 Task의 상태를 가져옵니다.</p> <pre>  finally:<br>    - name: notify-tasks<br>      taskRef:<br>        name: send-to-channel-slack<br>      params:<br>        - name: token-secret<br>          value: token-secret<br>        - name: channel<br>          value: &lt;channel_id&gt;<br>        - name: status<br>          value: "$(tasks.status)"<br>        - name: pipeline-name<br>          value: "$(context.pipeline.name)"<br>        - name: pipelinerun-name<br>          value: "$(context.pipelineRun.name)"<br>        - name: username<br>          value: "Tekton Bot"</pre> <p>이를 통해 슬랙에서 Tasks들의 상태에 따라서 성공과 실패 메세지를 확인할 수 있습니다.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/681/1*rAgg_kUdr7TKJTYkIQj4kQ.png"><figcaption>Tekton 성공 Slack Message</figcaption></figure> <p>다만 위의 내용 만으로 어떤 Task에서 발생했는지 구체적인 정보를 확인할 수 없습니다. 그러므로 추후 Tekton의 성격을 살려서 깔끔하고 정확한 슬랙 메세지를 작성하고 싶습니다.’</p> <h3>기타</h3> <p>Tekton 파일을 보시면 리소스의 재사용성을 고려하지 않고 작성했다는 것을 확인할 수 있습니다. 특히 글을 쓰는 과정에서 잘 작성하지 못했다는 것을 더욱 느낀 것 같습니다. 앞으로 시간이 있으면 지금까지 작성한 스크립트를 정리해야 겠습니다.</p> <h3>References</h3> <ul> <li><a href="https://velog.io/@sgwon1996/Jenkins-vs-GitHub-Action-vs-Tekton" rel="external nofollow noopener" target="_blank">Jenkins vs GitHub Action vs Tekton</a></li> <li><a href="https://gruuuuu.github.io/cloud/tekton-trigger/" rel="external nofollow noopener" target="_blank">Tekton Trigger를 사용하여 Pipeline 자동으로 돌려보기</a></li> <li><a href="https://techblog.lycorp.co.jp/ko/automate-streaming-pipeline-validation-with-kubernetes-native-workflows-2" rel="external nofollow noopener" target="_blank">https://techblog.lycorp.co.jp/ko/automate-streaming-pipeline-validation-with-kubernetes-native-workflows-2</a></li> <li><a href="https://tekton.dev/docs/pipelines/" rel="external nofollow noopener" target="_blank">https://tekton.dev/docs/pipelines/</a></li> <li><a href="https://tekton.dev/docs/triggers/cel_expressions/" rel="external nofollow noopener" target="_blank">https://tekton.dev/docs/triggers/cel_expressions/</a></li> <li><a href="https://medium.com/epam-delivery-platform/part-1-tekton-adoption-d5d47bf1bfc0" rel="external nofollow noopener" target="_blank">https://medium.com/epam-delivery-platform/part-1-tekton-adoption-d5d47bf1bfc0</a></li> <li><a href="https://tekton.dev/docs/pipelines/variables/" rel="external nofollow noopener" target="_blank">https://tekton.dev/docs/pipelines/variables/</a></li> </ul> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f4898483329c" width="1" height="1" alt="">&lt;hr&gt;&lt;p&gt;<a href="https://medium.com/s0okju-tech/gitops-%EC%A0%84%ED%99%98%EA%B8%B0-4-tekton%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-ci-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0-f4898483329c" rel="external nofollow noopener" target="_blank">GitOps 전환기 — Part 4. Tekton을 활용한 CI 구성하기</a> was originally published in <a href="https://medium.com/s0okju-tech" rel="external nofollow noopener" target="_blank">S0okJu Technology Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</p> </body></html>