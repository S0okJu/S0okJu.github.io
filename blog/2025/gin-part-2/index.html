<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h3><strong>Gin 예외처리 — Part 2. 커스텀 예외처리 구현하기</strong></h3> <p><a href="https://medium.com/s0okju-tech/gin-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC-part-1-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%BD%94%EB%93%9C%EB%A1%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%8A%94-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC-%EB%AC%B8%EC%A0%9C%EC%A0%90-c2afdf7e7be2" rel="external nofollow noopener" target="_blank">이전 글</a>에서는 Gin의 라이브러리를 활용하지 않고 예외처리를 구현할 시 발생할 수 있는 문제점에 대해 설명했습니다. 이제부터 Gin에서 제공하는 기능을 활용하여 예외처리를 수행하도록 하겠습니다.</p> <h3>Error Wrapping</h3> <h4>Gin에서의 예외 처리</h4> <p><a href="https://pkg.go.dev/github.com/gin-gonic/gin#Context.Error" rel="external nofollow noopener" target="_blank">Gin Error() 함수</a>에 의하면 Gin의 Context에 Error를 담은 후에 Middleware에서 처리하는 것을 권장하고 있습니다.</p> <blockquote> <em>Error attaches an error to the current context. The error is pushed to a list of errors. </em><strong><em>It’s a good idea to call Error for each error that occurred during the resolution of a request.</em></strong><em> A middleware can be used to collect all the errors and push them to a database together, print a log, or append it in the HTTP response. Error will panic if err is nil.</em> </blockquote> <p>라이브러리 코드를 보면Errors필드가 정의되어 있는데 errorMsg는[]*Error에러 리스트로 타입을 가지고 있습니다. 위의 설명대로 error의 리스트가 Context 내부에 구현되어 있는 것입니다.</p> <pre>// gin/context.go<br>type Context struct {  <br> // ... <br>   Errors errorMsgs<br> // .. <br>}<br><br>// gin/errors.go<br>type errorMsgs []*Error</pre> <p>즉,ctx.Error를 활용하여 입력받은 에러를 Gin의 에러로 감싼 후에 Context의 Errors 리스트에 넣게 됩니다.</p> <pre>// gin/context.go<br>// Error attaches an error to the current context. The error is pushed to a list of errors.// It's a good idea to call Error for each error that occurred during the resolution of a request.// A middleware can be used to collect all the errors and push them to a database together,  <br>// print a log, or append it in the HTTP response.  <br>// Error will panic if err is nil.<br>func (c *Context) Error(err error) *Error {  <br>    if err == nil {  <br>       panic("err is nil")  <br>    }  <br>  <br>    var parsedError *Error  <br>    ok := errors.As(err, &amp;parsedError)  <br>    if !ok {  <br>       parsedError = &amp;Error{  <br>          Err:  err,  <br>          Type: ErrorTypePrivate,  <br>       }  <br>    }  <br>  <br>    c.Errors = append(c.Errors, parsedError)  <br>    return parsedError  <br>}</pre> <p>Context 내부에 있는 Error 리스트는 Middleware에서 처리하게 됩니다.</p> <p>Gin에서는 <a href="https://pkg.go.dev/github.com/gin-gonic/gin#HandlerFunc" rel="external nofollow noopener" target="_blank">HandlerFunc</a>를 slice로 구현된 <a href="https://pkg.go.dev/github.com/gin-gonic/gin#HandlersChain" rel="external nofollow noopener" target="_blank">HandlerChain</a>이 있는데 이는 Gin이 각가지의 Handler를 Chain내에 넣고 처리됩니다.</p> <pre>type HandlersChain []HandlerFunc</pre> <p>그럼 오류를 어떻게 발생시키면 될까? HandlerChain 내에 있는 대기 중인(Pending) Handler를 호출하지 않도록 하면됩니다.</p> <p>즉, Context를 <a href="https://pkg.go.dev/github.com/gin-gonic/gin#Context.Abort" rel="external nofollow noopener" target="_blank">Abort</a>를 활용하여 이후 처리할 Handler가 없어지면서 종료시키는 것입니다.</p> <blockquote> <em>Abort prevents pending handlers from being called. Note that this will not stop the current handler. Let’s say you have an authorization middleware that validates that the current request is authorized. If the authorization fails (ex: the password does not match), </em><strong><em>call Abort to ensure the remaining handlers for this request are not called.</em></strong> </blockquote> <h3>프로젝트에 적용하기</h3> <h4>절차</h4> <p>위의 내용을 가지고 실제로 적용해보겠습니다.<br>프로젝트 구성은 3계층으로 구성되어 있으며 커스텀 에러 감싸기는 서비스 로직에 수행하도록 구현했습니다.</p> <ol> <li>Service 계층에 Error Wrapping을 한다.</li> <li>Controller에 context 내에 있는 에러 리스트에 예외를 넣는다.</li> <li>Middleware에 Error Wrapping한 것을 Unwrapping 하면서 예외 타입을 학인한다.</li> <li>커스텀 에러라면 WebCode에 따른 응답값을 반환한다.</li> </ol> <p>그림으로 표현하자면 아래와 같습니다.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xL_7nVFHJjSLONeBMbqYng.png"><figcaption>Custom error 구조도</figcaption></figure> <h4>코드</h4> <p>코드는 아래의 두 사이트를 참고했습니다.</p> <ul> <li><a href="https://d2.naver.com/helloworld/2690202" rel="external nofollow noopener" target="_blank">Naver D2, Golang, 그대들은 어떻게 할 것인가 — 3. error 래핑</a></li> <li><a href="https://d2.naver.com/helloworld/6507662" rel="external nofollow noopener" target="_blank">Naver D2, Golang, 그대들은 어떻게 할 것인가 — 4. error 핸들링</a></li> </ul> <p><strong>Service Layer</strong></p> <p>Persistence Layer에서 얻은 에러 값을 직접 받은 후에 Service 계층에서 적절하게 NetError로 감쌌습니다.</p> <pre>// service<br>func (s *MemberService) CreateMember(ctx *gin.Context, req data.RegisterReq) (*ent.Member, *errorutils.NetError) {<br> // Check member Exist<br> existedMem, err := s.Store.GetMemberByEmail(ctx, req.Email)<br> if err != nil {<br>  return nil, &amp;errorutils.NetError{Code: codes.MemberInternalServerError, Err: err}<br> }<br> if ent.IsNotFound(err) {<br>  mem, err2 := s.Store.Create(ctx, req)<br>  if err2 != nil {<br>   return nil, &amp;errorutils.NetError{Code: codes.MemberCreationError, Err: err2}<br>  }<br>  return mem, nil<br> }<br> return existedMem, nil<br>}</pre> <p><strong>Controller Layer</strong></p> <p>Controller는 Service 계층에서 감싼 커스텀 에러를 받은 후에 Context의 에러 리스트에 넣었습니다.</p> <pre>func (controller *MemberController) RegisterMember(ctx *gin.Context) {<br> req := data.RegisterReq{}<br> err := ctx.ShouldBindJSON(&amp;req)<br> if err != nil {<br>  _ = ctx.Error(errorutils.NewNetError(codes.MemberInvalidJson, err))<br>  return<br> }<br><br> // Create member<br> mem, err2 := controller.service.CreateMember(ctx, req)<br> if err2 != nil {<br>  // Service 계층에서 받은 에러를 Context 내 에러 리스트에 넣는다.<br>  _ = ctx.Error(err2)<br>  return<br> }<br><br> mid := data.MemberId{MemberId: mem.ID}<br> response.SuccessWith(ctx, codes.MemberCreationSuccess, mid)<br>}</pre> <p><strong>Middleware</strong></p> <p>에러 응답값을 반환할 HandlerFunc를 구현했습니다.</p> <ol> <li> <a href="https://pkg.go.dev/github.com/gin-gonic/gin#Context.Next" rel="external nofollow noopener" target="_blank">Next</a>를 활용하여 대기 중인 핸들러를 실행시킨다.</li> <li> <a href="https://pkg.go.dev/errors#example-As" rel="external nofollow noopener" target="_blank">errors.As</a>를 활용하여 Context 에러 리스트에 있는 에러가 커스텀 에러인지 확인한다. 정확히 말하자면 에러를 unwrapping하면서 커스텀 에러인지 확인한 후에 있다면 netError에 넣게 된다.</li> <li>WebCode를 활용하여 응답값을 얻은 후 <a href="https://pkg.go.dev/github.com/gin-gonic/gin#Context.AbortWithStatusJSON" rel="external nofollow noopener" target="_blank">AbortWithStatusJson</a> 를 활용하여 Response json을 전송한다.</li> </ol> <pre>func ErrorHandler() gin.HandlerFunc {  <br>    return func(ctx *gin.Context) {  <br>  // Pending 중인 핸들러 실행 <br>       ctx.Next()  <br>       // JSON이 두번 쓰이는 것을 대비해서 Body 확인  <br>       isBodyWritten := ctx.Writer.Written()  <br>       err := ctx.Errors.Last()  <br>  <br>       if err != nil {  <br>        // 커스텀 에러인지 확인 <br>          var netErr *errorutils.NetError  <br>          if errors.As(err, &amp;netErr) {  <br>             code := netErr.GetCode()  <br>             statusCode := codes.GetStatus(code)  <br>             res := response.NewErrorResponse(code)  <br>  <br>             // Abort with the appropriate status code and response  <br>             if !isBodyWritten {  <br>                ctx.AbortWithStatusJSON(int(statusCode), res)  <br>             }  <br>          } else {  <br>             res := response.NewErrorResponse(codes.GlobalInternalServerError)  <br>             if !isBodyWritten {  <br>                ctx.AbortWithStatusJSON(http.StatusInternalServerError, res)  <br>             }  <br>          }  <br>  <br>       }  <br>    }  <br>}</pre> <h3>마무리</h3> <p>Go의 예외 매커니즘은 다른 언어와 달라서 틀을 잡는데 많은 시간을 사용했습니다. 공식 문서나 다른 사람들의 예제 코드를 분석하면서, Go스러움이 무엇인지 조금 배운 것 같습니다.</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=eadba0b377ee" width="1" height="1" alt="">&lt;hr&gt;&lt;p&gt;<a href="https://medium.com/s0okju-tech/gin-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC-part-2-%EC%BB%A4%EC%8A%A4%ED%85%80-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-eadba0b377ee" rel="external nofollow noopener" target="_blank">Gin 예외처리 — Part 2. 커스텀 예외처리 구현하기</a> was originally published in <a href="https://medium.com/s0okju-tech" rel="external nofollow noopener" target="_blank">S0okJu Technology Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</p> </body></html>