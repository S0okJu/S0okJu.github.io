<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h3>Test Code 란?</h3> <p>테스트 코드는 소프트웨어의 기능과 동작을 테스트하는데 사용되는 코드입니다. 테스트 코드는 개발자가 작성한 코드를 실행하여 예상되는 결과가 나오는지 확인하며 소프트웨어 결함을 찾습니다.</p> <h3>종류</h3> <p>테스트 코드는 V 모델에 따라 크게 4가지로 나뉩니다. 각 테스트의 범위에 따라 예상 기댓값이 적절하게 맞는지 확인하여 테스트를 수행하게 됩니다.</p> <blockquote> <strong>V-모델</strong><br>소프트웨어 개발의 주요 단계들(비즈니스 요구사항 명세화에서 배포까지)과 상응하는 테스트 레벨(인수 테스팅에서 유닛 테스팅까지) 사이의 일대일 대응 관계를 설명하는 순차적 개발 수명주기 모델입니다.</blockquote> <figure><img alt="" src="https://cdn-images-1.medium.com/max/459/0*KAT3cjxOUcKMBLDG.png"><figcaption>출처 — <a href="https://www.testbytes.net/wp-content/uploads/2019/05/v-model-in-software-testing.png" rel="external nofollow noopener" target="_blank">https://www.testbytes.net/wp-content/uploads/2019/05/v-model-in-software-testing.png</a></figcaption></figure> <p>이 중 개발자는 단위 테스트와 통합 테스트를 주로 다루게 됩니다.</p> <ul> <li><strong>단위 테스트</strong></li> <li><strong>통합 테스트</strong></li> <li>시스템 테스트</li> <li>사용자 인수 테스트</li> </ul> <h3>Test Double</h3> <p>테스트를 목적으로 실제 객체, 연관된 객체를 직접 사용하기 어려울때 대신 사용하는 가짜 객체를 의미합니다.</p> <h4>사용 이유</h4> <ol> <li>실제 객체가 아직 개발되지 않았거나 접근이 불가능한 경우에 대한 테스트가 가능하다.</li> <li>복잡한 환경이나 시나리오를 간단하게 모의할 수 있다.</li> <li>테스트 실행 속도를 크게 향상시킬 수 있다.</li> <li>테스트의 독립성을 보장한다.</li> </ol> <p>테스트 더블을 활용하여 객체의 결과값을 예측할 수 있으며, 이를 활용하여 높은 품질의 소프트웨어를 더 빠르고 효과적으로 개발할 수 있게 됩니다.</p> <h4>종류</h4> <p>Test Double은 여러 종류가 있지만 그 중 단위 테스트에서 많이 활용되는 Fake, Stub, Mock에 대해서만 설명하겠습니다.</p> <figure><img alt="" src="https://cdn-images-1.medium.com/max/700/0*hKtNkKUIOVGIjRKc.jpg"><figcaption>출처 — <a href="https://dev-ellachoi.tistory.com/124" rel="external nofollow noopener" target="_blank">https://dev-ellachoi.tistory.com/124</a></figcaption></figure> <p><strong>Fake</strong><br>객체의 행동을 모방하여 제작합니다.</p> <p><strong>Stub</strong><br>특정 메서드가 정해진 응답값을 반환하는 객체입니다. Fake 객체와의 차이점은 <strong>응답값이 고정</strong>되어 있으며 <strong>상태</strong>를 검증하는데 사용됩니다.</p> <p><strong>Mock </strong><br>Mock는 <strong>반환값이 없는 함수나 특정 객체에서 특정 함수가 호출되었는지 테스트할때 사용</strong>됩니다. 즉, 내가 바라는대로 호출에 대한 기댓값을 명시하고, 명시한 내용에 따라서 잘 작동되는지 확인합니다. <br>Stub과 유사하지만 호출된 메서드에 대해 <strong>행위</strong>를 검증할 때 사용됩니다.</p> <h3>단위 테스트</h3> <h4>개념</h4> <p>단위 테스트는 소프트웨어 개발에서 일반적으로 사용되는 테스트 중 하나로, 개별적인 코드 단위가 의도한대로 작동하는지 확인합니다.</p> <h4>적용하기</h4> <p>실제 프로젝트에 적용해보겠습니다. <br>레포지토리에는 Challenge id로 조회하여 Challenge 객체를 반환하는 프라이빗 함수가 있습니다.</p> <pre>class ChallengeRepository:<br>    def __init__(self, session):<br>        self.session = session<br>    <br> # Challenge 객체를 가져오는 함수 <br>    def _get_challenge(self, challenge_id: int) -&gt; Challenges:<br>        """<br>        챌린지 아이디로 챌린지 조회<br>        <br>        Args:<br>            challenge_id (int): 챌린지 아이디<br>            <br>        Returns:<br>            Challenges: 챌린지 객체<br>            <br>        Raises:<br>            ChallengeNotFound: 챌린지가 존재하지 않을 때<br>            InternalServerError: DB 에러 발생 시<br>        """<br>        try:<br>            challenge = self.session.query(Challenges).get(challenge_id)<br>            if not challenge:<br>                raise ChallengeNotFound(error_msg=f"Challenge not found: {challenge_id}")<br>            <br>            return challenge<br>        except SQLAlchemyError as e:<br>            raise InternalServerError(error_msg=f"Error getting challenge by id {challenge_id}: {str(e)}") from e</pre> <p>테스트 코드는 Pytest를 중점적으로 사용하돼 unittest 모듈도 함께 사용하겠습니다.<br>pytest에서 지정한 <a href="https://docs.pytest.org/en/6.2.x/xunit_setup.html#method-and-function-level-setup-teardown" rel="external nofollow noopener" target="_blank">setup_method</a> 를 활용하여 클래스 내부에 있는 테스트코드를 실행하기 전에 필요한 변수를 지정합니다.</p> <p>여기서 MagicMock()를 활용하여 mock_session을 선언했습니다. session은 Flask 앱 초기화 시 데이터베이스에서 생성하는 객체입니다. 단위 테스트는 _get_challenge()에 대한 테스트만 수행하는 것이므로 session과 같은 외부 의존성을 임시 객체로 선언하여 사용합니다.</p> <pre>class TestChallengeRepositoryGetChallenge:<br>    def setup_method(self):<br>  # 임시 session을 만듭니다. <br>        self.mock_session = MagicMock()<br><br>  # mocking된 session을 활용하여 테스트할 레포지토리를 정의합니다. <br>        self.repository = ChallengeRepository(self.mock_session)</pre> <p>mocking된 Challenge 객체를 활용하여 레포지토리가 성공인지 테스트를 수행합니다.<br>여기서 활용된 test fixture란 중복 발생되는 행위를 고정시켜 한곳에 관리하는 개념이라고 보시면 됩니다. 추후 다른 함수에서도 활용될 예정이므로 fixture를 수행했습니다. <br>여기서 왜 Fake 객체가 아니라 Mock 객체로 선언했는지 궁금할 것입니다. _get_challenge()는 Challenge 객체를 최종적으로 반환합니다. 이 과정에서 <strong>발생하는 리턴 값, 예외값을 모두 테스트</strong>해야 합니다. 이처럼 다양한 행위를 테스트하기 위해서 Mock를 사용했습니다.</p> <pre>@pytest.fixture<br>def mock_challenge():<br>    """Mock challenge object"""<br>    challenge = MagicMock()<br>    challenge.id = 1<br>    challenge.title = "Test Challenge"<br>    return challenge<br><br>class TestChallengeRepositoryGetChallenge:<br> # ... <br>    def test_success(self, mock_challenge):<br>  #  self.repository._get_challenge(1) 반환 값이 mock_challenge<br>        self.mock_session.query().get.return_value = mock_challenge<br>        result = self.repository._get_challenge(1)<br>  <br>  # 결과 값 비교 <br>        assert result == mock_challenge<br><br> def test_challenge_does_not_exist(self):<br>  <br>  # 발생할 예외 : ChallengeNotFound<br>        self.mock_session.query().get.side_effect = ChallengeNotFound("Challenge not found")<br>  <br>  # 임시로 ChallengeNotFound 발생시키기<br>        with pytest.raises(ChallengeNotFound) as exc_info:<br>            self.repository._get_challenge(1)<br>  <br>  # 결과 확인하기 <br>        assert "Challenge not found" in str(exc_info.value)</pre> <p>레포지토리와 다르게 단순히 값만 반환하는 NameBuilder 함수를 확인해봅시다. <br>Namebuilder는 challenge_id, user_id를 입력 받아서 build() 함수를 통해 ChallengeInfo라는 객체를 반환합니다.</p> <pre>class NameBuilder:<br>    def __init__(self, challenge_id: int, user_id: int):<br>        self._challenge_id = challenge_id<br>        self._user_id = user_id<br>        <br>    def _is_valid_name(self, name:str) -&gt; bool:<br>        """Kubernetes 리소스 이름 유효성 검사"""<br>        name = name.lower()<br>        if not name or len(name) &gt; 253:<br>            return False<br>        pattern = r'^[a-z0-9]([-a-z0-9]*[a-z0-9])?$'<br>        return bool(re.match(pattern, name))<br>    <br>    def build(self) -&gt; Optional[ChallengeInfo]:<br>        """<br>        챌린지 이름 빌더 <br>        <br>        """<br>        challenge_info = ChallengeInfo(challenge_id=self._challenge_id, user_id=self._user_id)<br>        if not self._is_valid_name(challenge_info.name):<br>            raise InvalidName(error_msg = f"Invalid challenge name {challenge_info.name}")<br>        return challenge_info</pre> <p>이럴 경우 ChallengeInfo는 외부 의존성이 없는 단순한 클래스입니다. 그러므로 challenge_stub을 생성하여 값을 고정한 후 build 함수가 적절하게 응답했는지 확인하면 됩니다.</p> <pre>@pytest.fixture<br>def challengeinfo_stub():<br>    return ChallengeInfo(challenge_id=1, user_id=1)<br><br>class TestNameBuilder:<br>    def setup_method(self):<br>        self.namebuilder = NameBuilder(1, 1)<br>        <br>    def test_success(self, challengeinfo_stub):<br>        info = self.namebuilder.build()<br>        <br>        assert info.challenge_id == 1<br>        assert info.user_id == 1<br>        assert info.name == "challenge-1-1"</pre> <h3>테스트 코드를 사용하는 이유</h3> <ul> <li>내가 무엇을 만들고 있는지 정확히 인지</li> <li>리팩토링을 진행할 대 부담 덜어주기</li> <li>결합도와 의존성이 낮은 코드를 지향</li> </ul> <p>결국에는 <strong>요구사항에 적합하고 유지보수성이 높은 소프트웨어를 개발하기 위해서는 테스트 코드 작성이 필수</strong>입니다.</p> <h4>경험담</h4> <p>단순한 웹 애플리케이션을 개발할때는 테스트 코드의 필요성을 느끼지 못했습니다. 코드 전반이 단순하여 오류 발생 시 금방 발견하게 수정할 수 있었습니다. 그러나 2개 이상의 레포지토리, 2개 이상의 플랫폼을 활용하여 개발하면서 오류의 문제점을 재빠르게 확인할 수 없었습니다. <br>막상 테스트 코드를 짜려고 하니 결합도와 의존성이 높아서 개인적으로 힘들었던 기억이 있습니다. 리펙토링이 아니라 처음부터 다시 개발하는 수준으로 코드를 다시 작성해야 했습니다. <br>이론적으로는 필요성을 알고 있었습니다. 그러나 실제로 애플리케이션을 클라이언트에게 배포하다보니 테스트 코드의 중요성을 몸소 느끼고 있습니다. 현재 테스트 코드를 조금씩 작성하고 있습니다. 그때마다 고려하지 못한 오류 사항을 마주했고 이에 맞게 코드를 수정하고 있습니다.</p> <h3>References</h3> <ul> <li><a href="https://yozm.wishket.com/magazine/detail/1964/" rel="external nofollow noopener" target="_blank">테스트 코드는 왜 만들까? | 요즘IT</a></li> <li><a href="https://azderica.github.io/00-test-mock-and-stub/" rel="external nofollow noopener" target="_blank">[Test] Mock 테스트와 Stub 테스트 차이</a></li> <li>https://dev-test-hqsw.tistory.com/23</li> </ul> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=0a5f6c5f779c" width="1" height="1" alt="">&lt;hr&gt;&lt;p&gt;<a href="https://medium.com/s0okju-tech/testing-pytest%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EC%97%AC-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-0a5f6c5f779c" rel="external nofollow noopener" target="_blank">Testing: Pytest를 활용한 단위 테스트 구현</a> was originally published in <a href="https://medium.com/s0okju-tech" rel="external nofollow noopener" target="_blank">S0okJu Technology Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.&lt;/p&gt;</p> </body></html>